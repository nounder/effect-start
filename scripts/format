#!/usr/bin/env bun

type ClaudeToolInput =
  | {
    file_path: string
    old_string: string
    new_string: string
    replace_all?: boolean
  }
  | {
    file_path: string
    content: string
  }
  | {
    file_path: string
    limit?: number
    offset?: number
  }

type ClaudeHookInput = {
  session_id: string
  transcript_path: string
  cwd: string
  permission_mode: string
  hook_event_name: string
  tool_name: string
  tool_input: ClaudeToolInput
  tool_use_id: string
}

type ClaudeHookOutput = {
  hookSpecificOutput: {
    hookEventName: string
    permissionDecision: "allow" | "deny" | "ask"
    permissionDecisionReason?: string
    updatedInput?: ClaudeToolInput
  }
}

async function hook(input: ClaudeHookInput): Promise<ClaudeHookOutput> {
  const toolInput = input.tool_input


  // Handle Write tool with content
  if (
    "content" in toolInput &&
    "file_path" in toolInput &&
    toolInput.content
  ) {
      // Format the content with dprint
      const { formatString } = await import("dprint-cli")
      let formatted = toolInput.content
      let formatterFound = true
      try {
        formatted = await formatString({
          content: toolInput.content,
          filename: toolInput.file_path,
        })
      } catch {
        // No formatter available for this file type, use content as-is
        formatterFound = false
      }

      // Only apply format if content changed
      if (formatted !== toolInput.content) {
        // Content changed, applying format
        return {
          hookSpecificOutput: {
            hookEventName: "PreToolUse",
            permissionDecision: "allow",
            permissionDecisionReason: "Formatted with dprint",
            updatedInput: {
              file_path: toolInput.file_path,
              content: formatted,
            },
          },
        }
      } else {
        // Content unchanged, skipping format
        return {
          hookSpecificOutput: {
            hookEventName: "PreToolUse",
            permissionDecision: "allow",
            permissionDecisionReason: formatterFound ? "Already formatted" : "No formatter found for file type",
          },
        }
      }
    }

  // Handle Edit tool with old_string/new_string
  // Format new_string while keeping old_string unchanged for matching
  if (
    "old_string" in toolInput &&
    "new_string" in toolInput &&
    "file_path" in toolInput
  ) {
    const { formatString } = await import("dprint-cli")
    let formatted = toolInput.new_string
    let formatterFound = true
    try {
      formatted = await formatString({
        content: toolInput.new_string,
        filename: toolInput.file_path,
      })
    } catch {
      // No formatter available for this file type, use content as-is
      formatterFound = false
    }

    if (formatted !== toolInput.new_string) {
      // Content changed, applying format
      return {
        hookSpecificOutput: {
          hookEventName: "PreToolUse",
          permissionDecision: "allow",
          permissionDecisionReason: "Formatted new_string with dprint",
          updatedInput: {
            file_path: toolInput.file_path,
            old_string: toolInput.old_string,
            new_string: formatted,
          },
        },
      }
    } else {
      // Content unchanged, skipping format
      return {
        hookSpecificOutput: {
          hookEventName: "PreToolUse",
          permissionDecision: "allow",
          permissionDecisionReason: formatterFound ? "Already formatted" : "No formatter found for file type",
        },
      }
    }
  }

  // Pass through unchanged for other cases
  return {
    hookSpecificOutput: {
      hookEventName: "PreToolUse",
      permissionDecision: "allow",
      permissionDecisionReason: "Not applicable",
    },
  }
}


if (import.meta.main) {
  const stdin = await Bun.stdin.text()
  const input = JSON.parse(stdin)

  const output = await hook(input)
  const stdout = JSON.stringify(output)

  try{

  await Bun.stdout.write(stdout)
  } catch(e) {

  await Bun.file(process.cwd() + "/claude-hook.err").write(`${String(e)}\n${e.stacktrace}`)
  }

  await Bun.file(process.cwd() + "/claude-hook.in").write(stdin)
  await Bun.file(process.cwd() + "/claude-hook.out").write(stdout)
}

