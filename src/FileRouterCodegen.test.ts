import { FileSystem } from "@effect/platform"
import {
  expect,
  it,
  test,
} from "bun:test"
import { Effect } from "effect"
import { MemoryFileSystem } from "effect-memfs"
import { parseRoute } from "./FileRouter.ts"
import type { RouteHandle } from "./FileRouter.ts"
import * as FileRouterCodegen from "./FileRouterCodegen.ts"
import * as Route from "./Route.ts"
import { effectFn } from "./testing.ts"

test("generates code for routes only", () => {
  const handles: RouteHandle[] = [
    parseRoute("route.tsx"),
    parseRoute("about/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  const expected = `/**
 * Auto-generated by effect-start.
 */

import type { Router } from "effect-start"

export const modules = [
  {
    path: "/",
    segments: [],
    load: () => import("./route.tsx"),
  },
  {
    path: "/about",
    segments: [
      { literal: "about" },
    ],
    load: () => import("./about/route.tsx"),
  },
] as const
`

  expect(code)
    .toBe(expected)
})

test("generates code with layers", () => {
  const handles: RouteHandle[] = [
    parseRoute("layer.tsx"),
    parseRoute("route.tsx"),
    parseRoute("about/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  const expected = `/**
 * Auto-generated by effect-start.
 */

import type { Router } from "effect-start"

export const modules = [
  {
    path: "/",
    segments: [],
    load: () => import("./route.tsx"),
    layers: [
      () => import("./layer.tsx"),
    ],
  },
  {
    path: "/about",
    segments: [
      { literal: "about" },
    ],
    load: () => import("./about/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
    ],
  },
] as const
`

  expect(code)
    .toBe(expected)
})

test("generates code with nested layers", () => {
  const handles: RouteHandle[] = [
    parseRoute("layer.tsx"),
    parseRoute("dashboard/layer.tsx"),
    parseRoute("dashboard/route.tsx"),
    parseRoute("dashboard/settings/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  const expected = `/**
 * Auto-generated by effect-start.
 */

import type { Router } from "effect-start"

export const modules = [
  {
    path: "/dashboard",
    segments: [
      { literal: "dashboard" },
    ],
    load: () => import("./dashboard/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
      () => import("./dashboard/layer.tsx"),
    ],
  },
  {
    path: "/dashboard/settings",
    segments: [
      { literal: "dashboard" },
      { literal: "settings" },
    ],
    load: () => import("./dashboard/settings/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
      () => import("./dashboard/layer.tsx"),
    ],
  },
] as const
`

  expect(code)
    .toBe(expected)
})

test("only includes group layers for routes in that group", () => {
  const handles: RouteHandle[] = [
    parseRoute("layer.tsx"),
    parseRoute("(admin)/layer.ts"),
    parseRoute("(admin)/users/route.tsx"),
    parseRoute("movies/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  expect(code)
    .toContain("path: \"/users\"")

  expect(code)
    .toContain("path: \"/movies\"")

  // /users should have both root layer and (admin) layer
  expect(code)
    .toContain("() => import(\"./layer.tsx\")")

  expect(code)
    .toContain("() => import(\"./(admin)/layer.ts\")")

  // /movies should only have root layer, not (admin) layer
  const expectedMovies = `  {
    path: "/movies",
    segments: [
      { literal: "movies" },
    ],
    load: () => import("./movies/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
    ],
  },`

  expect(code)
    .toContain(expectedMovies)
})

test("handles dynamic routes with params", () => {
  const handles: RouteHandle[] = [
    parseRoute("users/route.tsx"),
    parseRoute("users/[userId]/route.tsx"),
    parseRoute("posts/[postId]/comments/[commentId]/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  expect(code)
    .toContain("path: \"/users\"")
  expect(code)
    .toContain("path: \"/users/[userId]\"")
  expect(code)
    .toContain("{ literal: \"users\" }")
  expect(code)
    .toContain("{ param: \"userId\" }")
  expect(code)
    .toContain("{ param: \"postId\" }")
  expect(code)
    .toContain("{ param: \"commentId\" }")
})

test("handles rest parameters", () => {
  const handles: RouteHandle[] = [
    parseRoute("docs/[[...slug]]/route.tsx"),
    parseRoute("api/[...path]/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  expect(code)
    .toContain("path: \"/docs/[[...slug]]\"")
  expect(code)
    .toContain("path: \"/api/[...path]\"")
  expect(code)
    .toContain("{ rest: \"slug\", optional: true }")
  expect(code)
    .toContain("{ rest: \"path\" }")
})

test("handles groups in path", () => {
  const handles: RouteHandle[] = [
    parseRoute("(admin)/users/route.tsx"),
    parseRoute("(admin)/layer.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  expect(code)
    .toContain("path: \"/users\"") // groups stripped from URL
  expect(code)
    .toContain("{ group: \"admin\" }")
  expect(code)
    .toContain("layers: [\n      () => import(\"./(admin)/layer.tsx\"),\n    ]")
})

test("generates correct variable names for root routes", () => {
  const handles: RouteHandle[] = [
    parseRoute("route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  expect(code)
    .toContain("path: \"/\"")
  expect(code)
    .toContain("segments: []")
})

test("handles routes with dots in path segments", () => {
  const handles: RouteHandle[] = [
    parseRoute("events.json/route.ts"),
    parseRoute("config.yaml.backup/route.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  expect(code)
    .toContain("path: \"/events.json\"")
  expect(code)
    .toContain("path: \"/config.yaml.backup\"")
  expect(code)
    .toContain("{ literal: \"events.json\" }")
  expect(code)
    .toContain("{ literal: \"config.yaml.backup\" }")
})

test("uses default module identifier", () => {
  const handles: RouteHandle[] = [
    parseRoute("route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  expect(code)
    .toContain("import type { Router } from \"effect-start\"")
})

test("generates empty modules array when no handles provided", () => {
  const handles: RouteHandle[] = []

  const code = FileRouterCodegen.generateCode(handles)

  expect(code)
    .toContain("export const modules = [] as const")
})

test("only includes routes in modules, not layers", () => {
  const handles: RouteHandle[] = [
    parseRoute("layer.tsx"),
    parseRoute("users/layer.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  expect(code)
    .toContain("export const modules = [] as const")
})

test("complex nested routes with multiple layers", () => {
  const handles: RouteHandle[] = [
    parseRoute("layer.tsx"),
    parseRoute("(auth)/layer.tsx"),
    parseRoute("(auth)/login/route.tsx"),
    parseRoute("(auth)/signup/route.tsx"),
    parseRoute("dashboard/layer.tsx"),
    parseRoute("dashboard/route.tsx"),
    parseRoute("dashboard/settings/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  expect(code)
    .toContain("path: \"/login\"") // group stripped
  expect(code)
    .toContain("path: \"/signup\"") // group stripped
  expect(code)
    .toContain("path: \"/dashboard\"")
  expect(code)
    .toContain("path: \"/dashboard/settings\"")

  // Check layers are properly inherited
  expect(code)
    .toContain("() => import(\"./layer.tsx\")")
  expect(code)
    .toContain("() => import(\"./(auth)/layer.tsx\")")
  expect(code)
    .toContain("() => import(\"./dashboard/layer.tsx\")")
})

test("handles routes with hyphens and underscores in path segments", () => {
  const handles: RouteHandle[] = [
    parseRoute("api-v1/route.ts"),
    parseRoute("my_resource/route.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  expect(code)
    .toContain("path: \"/api-v1\"")
  expect(code)
    .toContain("path: \"/my_resource\"")
  expect(code)
    .toContain("{ literal: \"api-v1\" }")
  expect(code)
    .toContain("{ literal: \"my_resource\" }")
})

test("validateRouteModule returns true for valid modules", () => {
  const validRoute = Route.text(Effect.succeed("Hello"))

  expect(
    FileRouterCodegen.validateRouteModule({ default: validRoute }),
  )
    .toBe(true)

  expect(
    FileRouterCodegen.validateRouteModule({
      default: Route.html(Effect.succeed("<div>Hello</div>")),
    }),
  )
    .toBe(true)

  expect(
    FileRouterCodegen.validateRouteModule({
      default: Route.json(Effect.succeed({ message: "Hello" })),
    }),
  )
    .toBe(true)
})

test("validateRouteModule returns false for invalid modules", () => {
  expect(FileRouterCodegen.validateRouteModule({}))
    .toBe(false)

  expect(
    FileRouterCodegen.validateRouteModule({ default: {} }),
  )
    .toBe(false)

  expect(
    FileRouterCodegen.validateRouteModule({ default: "not a route" }),
  )
    .toBe(false)

  expect(
    FileRouterCodegen.validateRouteModule({ foo: "bar" }),
  )
    .toBe(false)

  expect(FileRouterCodegen.validateRouteModule(null))
    .toBe(false)

  expect(FileRouterCodegen.validateRouteModule(undefined))
    .toBe(false)

  expect(FileRouterCodegen.validateRouteModule("string"))
    .toBe(false)

  expect(FileRouterCodegen.validateRouteModule(42))
    .toBe(false)
})

test("mixed params and rest in same route", () => {
  const handles: RouteHandle[] = [
    parseRoute("users/[userId]/files/[...path]/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  expect(code)
    .toContain("{ param: \"userId\" }")
  expect(code)
    .toContain("{ rest: \"path\" }")
})

const effect = effectFn()

const update_FilesWithRoutes = {
  "/routes/route.tsx": "",
  "/routes/about/route.tsx": "",
  "/routes/_manifest.ts": "",
}

it("update() > writes file", () =>
  Effect
    .gen(function*() {
      yield* FileRouterCodegen.update("/routes")

      const fs = yield* FileSystem.FileSystem
      const content = yield* fs.readFileString("/routes/_manifest.ts")

      expect(content)
        .toContain("export const modules =")
    })
    .pipe(
      Effect.provide(MemoryFileSystem.layerWith(update_FilesWithRoutes)),
      Effect.runPromise,
    ))

it("update() > writes only when it changes", () =>
  Effect
    .gen(function*() {
      yield* FileRouterCodegen.update("/routes")

      const fs = yield* FileSystem.FileSystem
      const content = yield* fs.readFileString("/routes/_manifest.ts")

      yield* FileRouterCodegen.update("/routes")

      const content2 = yield* fs.readFileString("/routes/_manifest.ts")

      expect(content2)
        .not
        .toBe("")

      expect(content2)
        .toBe(content)
    })
    .pipe(
      Effect.provide(MemoryFileSystem.layerWith(update_FilesWithRoutes)),
      Effect.runPromise,
    ))
