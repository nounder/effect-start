import { FileSystem } from "@effect/platform"
import {
  afterEach,
  describe,
  expect,
  it,
  test,
} from "bun:test"
import { Effect } from "effect"
import { MemoryFileSystem } from "effect-memfs"
import * as NPath from "node:path"
import * as FileRouter from "./FileRouter.ts"
import { parseRoute } from "./FileRouter.ts"
import type { RouteHandle } from "./FileRouter.ts"
import * as FileRouterCodegen from "./FileRouterCodegen.ts"
import { effectFn } from "./testing.ts"

it("generates code for pages only", () => {
  const handles: RouteHandle[] = [
    parseRoute("_page.tsx"),
    parseRoute("about/_page.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  const expected = `/** 
 * Auto-generated by effect-start.
 */

import type { Router } from "effect-start"

const page__ = {
  path: "/",
  load: () => import("./_page.tsx"),
} as const

const page__about = {
  path: "/about",
  load: () => import("./about/_page.tsx"),
} as const

export const Layouts: Router.LayoutRoutes = [] as const

export const Pages: Router.PageRoutes = [
  page__,
  page__about
] as const

export const Servers: Router.ServerRoutes = [] as const
 `

  expect(code)
    .toBe(expected)
})

it("generates code for server endpoints only", () => {
  const handles: RouteHandle[] = [
    parseRoute("api/_server.ts"),
    parseRoute("api/users/_server.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  const expected = `/** 
 * Auto-generated by effect-start.
 */

import type { Router } from "effect-start"

const server__api = {
  path: "/api",
  load: () => import("./api/_server.ts"),
} as const

const server__api__users = {
  path: "/api/users",
  load: () => import("./api/users/_server.ts"),
} as const

export const Layouts: Router.LayoutRoutes = [] as const

export const Pages: Router.PageRoutes = [] as const

export const Servers: Router.ServerRoutes = [
  server__api,
  server__api__users
] as const
 `

  expect(code)
    .toBe(expected)
})

it("generates code for mixed pages, layouts, and server endpoints", () => {
  const handles: RouteHandle[] = [
    parseRoute("_layout.tsx"),
    parseRoute("_page.tsx"),
    parseRoute("api/_server.ts"),
    parseRoute("dashboard/_layout.tsx"),
    parseRoute("dashboard/_page.tsx"),
    parseRoute("dashboard/api/_server.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  const expected = `/** 
 * Auto-generated by effect-start.
 */

import type { Router } from "effect-start"

const layout__ = {
  path: "/",
  load: () => import("./_layout.tsx"),
} as const

const page__ = {
  path: "/",
  parent: layout__,
  load: () => import("./_page.tsx"),
} as const

const server__api = {
  path: "/api",
  load: () => import("./api/_server.ts"),
} as const

const layout__dashboard = {
  path: "/dashboard",
  parent: layout__,
  load: () => import("./dashboard/_layout.tsx"),
} as const

const page__dashboard = {
  path: "/dashboard",
  parent: layout__dashboard,
  load: () => import("./dashboard/_page.tsx"),
} as const

const server__dashboard__api = {
  path: "/dashboard/api",
  load: () => import("./dashboard/api/_server.ts"),
} as const

export const Layouts: Router.LayoutRoutes = [
  layout__,
  layout__dashboard
] as const

export const Pages: Router.PageRoutes = [
  page__,
  page__dashboard
] as const

export const Servers: Router.ServerRoutes = [
  server__api,
  server__dashboard__api
] as const
 `

  expect(code)
    .toBe(expected)
})

it("handles dynamic routes in server endpoints", () => {
  const handles: RouteHandle[] = [
    parseRoute("api/users/$userId/_server.ts"),
    parseRoute("api/posts/$postId/comments/$commentId/_server.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  expect(code).toContain("const server__api__users__$userId = {")
  expect(code).toContain(
    "const server__api__posts__$postId__comments__$commentId = {",
  )
  expect(code).toContain("path: \"/api/users/$userId\"")
  expect(code).toContain("path: \"/api/posts/$postId/comments/$commentId\"")
})

it("handles splat routes in server endpoints", () => {
  const handles: RouteHandle[] = [
    parseRoute("api/files/$/_server.ts"),
    parseRoute("proxy/$/_server.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  expect(code).toContain("const server__api__files__$ = {")
  expect(code).toContain("const server__proxy__$ = {")
  expect(code).toContain("path: \"/api/files/$\"")
  expect(code).toContain("path: \"/proxy/$\"")
})

it("generates correct variable names for root routes", () => {
  const handles: RouteHandle[] = [
    parseRoute("_page.tsx"),
    parseRoute("_layout.tsx"),
    parseRoute("_server.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  // Root routes should have double underscore after prefix (e.g., page__, layout__, server__)
  expect(code).toContain("const layout__ = {")
  expect(code).toContain("const page__ = {")
  expect(code).toContain("const server__ = {")
  expect(code).toContain("path: \"/\"")
})

it("generates empty exports when no handles provided", () => {
  const handles: RouteHandle[] = []

  const code = FileRouterCodegen.generateCode(handles)

  expect(code).toContain("export const Pages: Router.PageRoutes = [] as const")
  expect(code).toContain(
    "export const Servers: Router.ServerRoutes = [] as const",
  )
  expect(code).toContain(
    "export const Layouts: Router.LayoutRoutes = [] as const",
  )

  // Should not contain any const definitions
  expect(code).not.toMatch(/const (page|layout|server)__/)
})

it("getHandlePrefix returns correct prefixes for all handle types", () => {
  expect(FileRouterCodegen.getHandlePrefix("PageHandle")).toBe("page")
  expect(FileRouterCodegen.getHandlePrefix("LayoutHandle")).toBe("layout")
  expect(FileRouterCodegen.getHandlePrefix("ServerHandle")).toBe("server")
})

it("server endpoints don't include parent layout references", () => {
  const handles: RouteHandle[] = [
    parseRoute("dashboard/_layout.tsx"),
    parseRoute("dashboard/_page.tsx"),
    parseRoute("dashboard/api/_server.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  // Page should reference layout as parent
  expect(code).toMatch(
    /const page__dashboard = \{[\s\S]*?parent: layout__dashboard/,
  )

  // Server should not reference parent (no parent property)
  expect(code).toMatch(
    /const server__dashboard__api = \{[\s\S]*?path: "\/dashboard\/api"[\s\S]*?load:/,
  )
  expect(code).not.toMatch(/const server__dashboard__api = \{[\s\S]*?parent:/)
})

it("maintains proper variable ordering in exports", () => {
  const handles: RouteHandle[] = [
    parseRoute("b/_page.tsx"),
    parseRoute("a/_page.tsx"),
    parseRoute("c/_server.ts"),
    parseRoute("a/_server.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  // Variables should be generated based on the order they appear in handles array
  const pageExportMatch = code.match(
    /export const Pages: Router\.PageRoutes = \[([\s\S]*?)\] as const/,
  )
  const httpExportMatch = code.match(
    /export const Servers: Router\.ServerRoutes = \[([\s\S]*?)\] as const/,
  )

  expect(pageExportMatch)
    .toBeTruthy()

  expect(httpExportMatch)
    .toBeTruthy()

  const pagesContent = pageExportMatch![1].trim()
  const httpContent = httpExportMatch![1].trim()

  // Check that pages are exported in the order they were processed

  expect(pagesContent)
    .toMatch(/page__b,\s*page__a/)

  // Check that servers are exported in the order they were processed

  expect(httpContent)
    .toMatch(/server__c,\s*server__a/)
})

it("generates proper code structure", () => {
  const handles: RouteHandle[] = [parseRoute("_page.tsx")]
  const code = FileRouterCodegen.generateCode(handles)

  // Should have proper structure

  expect(code)
    .toContain("const page__ = {")

  expect(code)
    .toMatch(
      /export const Pages: Router\.PageRoutes = \[[\s\S]*?\] as const\s*\n\s*export const Servers: Router\.ServerRoutes = \[/,
    )
})

it("validateServerModule returns true for valid modules", () => {
  // HTTP verb exports

  expect(
    FileRouterCodegen.validateServerModule({
      GET: "handler",
    }),
  )
    .toBe(true)

  expect(
    FileRouterCodegen.validateServerModule({
      POST: "handler",
    }),
  )
    .toBe(true)

  expect(
    FileRouterCodegen.validateServerModule({
      PUT: "handler",
    }),
  )
    .toBe(true)

  expect(FileRouterCodegen.validateServerModule({
    DELETE: "handler",
  }))
    .toBe(true)

  expect(
    FileRouterCodegen.validateServerModule({
      PATCH: "handler",
    }),
  )
    .toBe(true)

  expect(
    FileRouterCodegen.validateServerModule({
      HEAD: "handler",
    }),
  )
    .toBe(true)

  expect(
    FileRouterCodegen.validateServerModule({
      OPTIONS: "handler",
    }),
  )
    .toBe(true)

  // Default export

  expect(
    FileRouterCodegen.validateServerModule({
      default: "handler",
    }),
  )
    .toBe(true)

  // Mixed exports

  expect(
    FileRouterCodegen.validateServerModule({
      GET: "get",
      POST: "post",
    }),
  )
    .toBe(true)

  expect(
    FileRouterCodegen.validateServerModule({
      GET: "get",
      default: "handler",
    }),
  )
    .toBe(true)
})

it("validateServerModule returns false for invalid modules", () => {
  // No valid exports

  expect(
    FileRouterCodegen.validateServerModule({}),
  )
    .toBe(false)

  expect(
    FileRouterCodegen.validateServerModule({
      someOtherExport: "value",
    }),
  )
    .toBe(false)

  expect(
    FileRouterCodegen.validateServerModule({
      INVALID: "verb",
    }),
  )
    .toBe(false)

  expect(
    FileRouterCodegen.validateServerModule({
      get: "lowercase",
    }),
  )
    .toBe(false)
})

it("validateServerModule edge cases", () => {
  // Case sensitivity

  expect(
    FileRouterCodegen.validateServerModule({
      get: "lowercase",
    }),
  )
    .toBe(false)

  expect(
    FileRouterCodegen.validateServerModule({
      Get: "mixed",
    }),
  )
    .toBe(false)

  // Similar but invalid keys

  expect(
    FileRouterCodegen.validateServerModule({
      GETS: "plural",
    }),
  )
    .toBe(false)

  expect(
    FileRouterCodegen.validateServerModule({
      DEFAULT: "uppercase",
    }),
  )
    .toBe(false)

  // Valid mixed with invalid

  expect(
    FileRouterCodegen.validateServerModule({
      GET: "valid",
      invalid: "key",
    }),
  )
    .toBe(true)
})

it("validates server module integration with generateCode", () => {
  // Test that server handles are properly processed in the code generation
  const handles = [
    parseRoute("api/_server.ts"),
    parseRoute("_page.tsx"),
    parseRoute("users/_server.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  // Verify the generated code includes server endpoints

  expect(code)
    .toContain("const server__api = {")

  expect(code)
    .toContain("const server__users = {")

  expect(code)
    .toContain("export const Servers: Router.ServerRoutes = [")

  expect(code)
    .toContain("server__api,")

  expect(code)
    .toContain("server__users")

  // Verify that server handles are correctly processed separate from pages

  expect(code)
    .toContain("const page__ = {")

  expect(code)
    .toContain("export const Pages: Router.PageRoutes = [")

  expect(code)
    .toContain("page__")
})

it("validation logic handles complex module structures", () => {
  // Test various realistic module export patterns

  // Multiple HTTP verbs
  const multiVerbModule = {
    GET: () => "get handler",
    POST: () => "post handler",
    someHelper: "utility function",
  }

  expect(
    FileRouterCodegen.validateServerModule(multiVerbModule),
  )
    .toBe(true)

  // Default with other exports
  const defaultWithOthers = {
    default: () => "default handler",
    middleware: () => "middleware",
    config: { timeout: 5000 },
  }

  expect(
    FileRouterCodegen.validateServerModule(defaultWithOthers),
  )
    .toBe(true)

  // Only utility exports (invalid)
  const utilityOnly = {
    helper: () => "helper",
    config: { port: 3000 },
    constants: ["a", "b", "c"],
  }

  expect(
    FileRouterCodegen.validateServerModule(utilityOnly),
  )
    .toBe(false)
})

it("validation works with realistic server module patterns", () => {
  // Simulate real Effect HttpApp patterns
  const effectServerModule = {
    GET: "HttpServerResponse.text('GET response')",
    POST: "Effect.gen(function*() { /* ... */ })",
    middleware: "some middleware function",
  }

  expect(
    FileRouterCodegen.validateServerModule(effectServerModule),
  )
    .toBe(true)

  // API route with fallback
  const apiRouteModule = {
    GET: "Effect.succeed(Response.json(data))",
    default: "Effect.gen(function*() { /* fallback */ })",
  }

  expect(
    FileRouterCodegen.validateServerModule(apiRouteModule),
  )
    .toBe(true)

  // Route with only non-HTTP exports (invalid)
  const invalidModule = {
    helper: () => {},
    config: {},
    utils: [],
  }

  expect(
    FileRouterCodegen.validateServerModule(invalidModule),
  )
    .toBe(false)
})

it("handles routes with dots in path segments", () => {
  const handles: RouteHandle[] = [
    parseRoute("events.json/_server.ts"),
    parseRoute("config.yaml.backup/_page.tsx"),
    parseRoute("api.v2/_server.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  // Dots should be converted to underscores in variable names
  expect(code).toContain("const server__events_json = {")
  expect(code).toContain("const page__config_yaml_backup = {")
  expect(code).toContain("const server__api_v2 = {")

  // But original paths should be preserved in path property
  expect(code).toContain("path: \"/events.json\"")
  expect(code).toContain("path: \"/config.yaml.backup\"")
  expect(code).toContain("path: \"/api.v2\"")
})

it("handles routes with special characters (tilde and hyphen)", () => {
  const handles: RouteHandle[] = [
    parseRoute("api-v1/_server.ts"),
    parseRoute("files~backup/_page.tsx"),
    parseRoute("test-route~temp/_server.ts"),
    parseRoute("user-profile.json~cache/_page.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  // Special characters should be converted to underscores in variable names
  expect(code).toContain("const server__api_v1 = {")
  expect(code).toContain("const page__files_backup = {")
  expect(code).toContain("const server__test_route_temp = {")
  expect(code).toContain("const page__user_profile_json_cache = {")

  // But original paths should be preserved in path property
  expect(code).toContain("path: \"/api-v1\"")
  expect(code).toContain("path: \"/files~backup\"")
  expect(code).toContain("path: \"/test-route~temp\"")
  expect(code).toContain("path: \"/user-profile.json~cache\"")
})

it("allows customizing router module identifier", () => {
  const handles: RouteHandle[] = [
    parseRoute("_page.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles, {
    routerModuleId: "@my/custom-router",
  })

  expect(code).toContain("import type { Router } from \"@my/custom-router\"")
  expect(code).toContain("export const Pages: Router.PageRoutes = [")
})

it("uses default module identifier when not specified", () => {
  const handles: RouteHandle[] = [
    parseRoute("_page.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  expect(code).toContain("import type { Router } from \"effect-start\"")
})

describe("update()", () => {
  test("writes file", () =>
    effectFn(
      MemoryFileSystem.layerWith({
        "/routes/_page.tsx": "export default () => <div>Home</div>",
        "/routes/about/_page.tsx": "export default () => <div>About</div>",
      }),
    )(function*() {
      const fs = yield* FileSystem.FileSystem

      yield* FileRouterCodegen.update("/routes")

      const manifestExists = yield* fs.exists("/routes/_manifest.ts")

      expect(manifestExists)
        .toBe(true)

      const manifest = yield* fs.readFileString("/routes/_manifest.ts")

      expect(manifest)
        .toContain("const page__ = {")

      expect(manifest)
        .toContain("const page__about = {")

      expect(manifest)
        .toContain("export const Pages: Router.PageRoutes = [")
    }))

  test("writes only when it changes", () =>
    effectFn(
      MemoryFileSystem.layerWith({
        "/routes/_page.tsx": "export default () => <div>Home</div>",
      }),
    )(function*() {
      const fs = yield* FileSystem.FileSystem

      yield* FileRouterCodegen.update("/routes")

      const originalManifest = yield* fs.readFileString("/routes/_manifest.ts")

      yield* fs.makeDirectory("/routes/about", { recursive: true })
      yield* fs.writeFileString(
        "/routes/about/_page.tsx",
        "export default () => <div>About</div>",
      )

      yield* FileRouterCodegen.update("/routes")

      const updatedManifest = yield* fs.readFileString("/routes/_manifest.ts")

      expect(originalManifest)
        .not
        .toBe(updatedManifest)

      expect(updatedManifest)
        .toContain("const page__about = {")

      expect(originalManifest)
        .not
        .toContain("const page__about = {")
    }))

  test("skips write when unchanged", () =>
    effectFn(
      MemoryFileSystem.layerWith({
        "/routes/_page.tsx": "export default () => <div>Home</div>",
      }),
    )(function*() {
      const fs = yield* FileSystem.FileSystem

      yield* FileRouterCodegen.update("/routes")

      const originalManifest = yield* fs.readFileString("/routes/_manifest.ts")
      const originalStats = yield* fs.stat("/routes/_manifest.ts")

      yield* Effect.sleep("10 millis")

      yield* FileRouterCodegen.update("/routes")

      const updatedManifest = yield* fs.readFileString("/routes/_manifest.ts")
      const updatedStats = yield* fs.stat("/routes/_manifest.ts")

      expect(originalManifest)
        .toBe(updatedManifest)

      expect(originalStats.mtime)
        .toEqual(updatedStats.mtime)
    }))
})
