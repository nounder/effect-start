import * as FileSystem from "@effect/platform/FileSystem"
import * as t from "bun:test"
import { MemoryFileSystem } from "effect-memfs"
import * as Effect from "effect/Effect"
import { parseRoute } from "./FileRouter.ts"
import type { RouteHandle } from "./FileRouter.ts"
import * as FileRouterCodegen from "./FileRouterCodegen.ts"
import * as Route from "./Route.ts"
import { effectFn } from "./testing.ts"

t.it("generates code for routes only", () => {
  const handles: RouteHandle[] = [
    parseRoute("route.tsx"),
    parseRoute("about/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  const expected = `/**
 * Auto-generated by effect-start.
 */

import type { Router } from "effect-start"

export const routes = [
  {
    path: "/",
    load: () => import("./route.tsx"),
  },
  {
    path: "/about",
    load: () => import("./about/route.tsx"),
  },
] as const
`

  t
    .expect(code)
    .toBe(expected)
})

t.it("generates code with layers", () => {
  const handles: RouteHandle[] = [
    parseRoute("layer.tsx"),
    parseRoute("route.tsx"),
    parseRoute("about/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  const expected = `/**
 * Auto-generated by effect-start.
 */

import type { Router } from "effect-start"

export const routes = [
  {
    path: "/",
    load: () => import("./route.tsx"),
    layers: [
      () => import("./layer.tsx"),
    ],
  },
  {
    path: "/about",
    load: () => import("./about/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
    ],
  },
] as const
`

  t
    .expect(code)
    .toBe(expected)
})

t.it("generates code with nested layers", () => {
  const handles: RouteHandle[] = [
    parseRoute("layer.tsx"),
    parseRoute("dashboard/layer.tsx"),
    parseRoute("dashboard/route.tsx"),
    parseRoute("dashboard/settings/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  const expected = `/**
 * Auto-generated by effect-start.
 */

import type { Router } from "effect-start"

export const routes = [
  {
    path: "/dashboard",
    load: () => import("./dashboard/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
      () => import("./dashboard/layer.tsx"),
    ],
  },
  {
    path: "/dashboard/settings",
    load: () => import("./dashboard/settings/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
      () => import("./dashboard/layer.tsx"),
    ],
  },
] as const
`

  t
    .expect(code)
    .toBe(expected)
})

t.it("only includes group layers for routes in that group", () => {
  const handles: RouteHandle[] = [
    parseRoute("layer.tsx"),
    parseRoute("(admin)/layer.ts"),
    parseRoute("(admin)/users/route.tsx"),
    parseRoute("movies/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("path: \"/users\"")

  t
    .expect(code)
    .toContain("path: \"/movies\"")

  // /users should have both root layer and (admin) layer
  t
    .expect(code)
    .toContain("() => import(\"./layer.tsx\")")

  t
    .expect(code)
    .toContain("() => import(\"./(admin)/layer.ts\")")

  // /movies should only have root layer, not (admin) layer
  const expectedMovies = `  {
    path: "/movies",
    load: () => import("./movies/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
    ],
  },`

  t
    .expect(code)
    .toContain(expectedMovies)
})

t.it("handles dynamic routes with params", () => {
  const handles: RouteHandle[] = [
    parseRoute("users/route.tsx"),
    parseRoute("users/[userId]/route.tsx"),
    parseRoute("posts/[postId]/comments/[commentId]/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("path: \"/users\"")
  t
    .expect(code)
    .toContain("path: \"/users/[userId]\"")
  t
    .expect(code)
    .toContain("path: \"/posts/[postId]/comments/[commentId]\"")
})

t.it("handles rest parameters", () => {
  const handles: RouteHandle[] = [
    parseRoute("docs/[[...slug]]/route.tsx"),
    parseRoute("api/[...path]/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("path: \"/docs/[[...slug]]\"")
  t
    .expect(code)
    .toContain("path: \"/api/[...path]\"")
})

t.it("handles groups in path", () => {
  const handles: RouteHandle[] = [
    parseRoute("(admin)/users/route.tsx"),
    parseRoute("(admin)/layer.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("path: \"/users\"") // groups stripped from URL
  t
    .expect(code)
    .toContain("layers: [\n      () => import(\"./(admin)/layer.tsx\"),\n    ]")
})

t.it("generates correct variable names for root routes", () => {
  const handles: RouteHandle[] = [
    parseRoute("route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("path: \"/\"")
})

t.it("handles routes with dots in path segments", () => {
  const handles: RouteHandle[] = [
    parseRoute("events.json/route.ts"),
    parseRoute("config.yaml.backup/route.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("path: \"/events.json\"")
  t
    .expect(code)
    .toContain("path: \"/config.yaml.backup\"")
})

t.it("uses default module identifier", () => {
  const handles: RouteHandle[] = [
    parseRoute("route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("import type { Router } from \"effect-start\"")
})

t.it("generates empty routes array when no handles provided", () => {
  const handles: RouteHandle[] = []

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("export const routes = [] as const")
})

t.it("only includes routes, not layers", () => {
  const handles: RouteHandle[] = [
    parseRoute("layer.tsx"),
    parseRoute("users/layer.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("export const routes = [] as const")
})

t.it("complex nested routes with multiple layers", () => {
  const handles: RouteHandle[] = [
    parseRoute("layer.tsx"),
    parseRoute("(auth)/layer.tsx"),
    parseRoute("(auth)/login/route.tsx"),
    parseRoute("(auth)/signup/route.tsx"),
    parseRoute("dashboard/layer.tsx"),
    parseRoute("dashboard/route.tsx"),
    parseRoute("dashboard/settings/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("path: \"/login\"") // group stripped
  t
    .expect(code)
    .toContain("path: \"/signup\"") // group stripped
  t
    .expect(code)
    .toContain("path: \"/dashboard\"")
  t
    .expect(code)
    .toContain("path: \"/dashboard/settings\"")

  // Check layers are properly inherited
  t
    .expect(code)
    .toContain("() => import(\"./layer.tsx\")")
  t
    .expect(code)
    .toContain("() => import(\"./(auth)/layer.tsx\")")
  t
    .expect(code)
    .toContain("() => import(\"./dashboard/layer.tsx\")")
})

t.it("handles routes with hyphens and underscores in path segments", () => {
  const handles: RouteHandle[] = [
    parseRoute("api-v1/route.ts"),
    parseRoute("my_resource/route.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("path: \"/api-v1\"")
  t
    .expect(code)
    .toContain("path: \"/my_resource\"")
})

t.it("validateRouteModule returns true for valid modules", () => {
  const validRoute = Route.text(Effect.succeed("Hello"))

  t
    .expect(
      FileRouterCodegen.validateRouteModule({ default: validRoute }),
    )
    .toBe(true)

  t
    .expect(
      FileRouterCodegen.validateRouteModule({
        default: Route.html(Effect.succeed("<div>Hello</div>")),
      }),
    )
    .toBe(true)

  t
    .expect(
      FileRouterCodegen.validateRouteModule({
        default: Route.json(Effect.succeed({ message: "Hello" })),
      }),
    )
    .toBe(true)
})

t.it("validateRouteModule returns false for invalid modules", () => {
  t
    .expect(FileRouterCodegen.validateRouteModule({}))
    .toBe(false)

  t
    .expect(
      FileRouterCodegen.validateRouteModule({ default: {} }),
    )
    .toBe(false)

  t
    .expect(
      FileRouterCodegen.validateRouteModule({ default: "not a route" }),
    )
    .toBe(false)

  t
    .expect(
      FileRouterCodegen.validateRouteModule({ foo: "bar" }),
    )
    .toBe(false)

  t
    .expect(FileRouterCodegen.validateRouteModule(null))
    .toBe(false)

  t
    .expect(FileRouterCodegen.validateRouteModule(undefined))
    .toBe(false)

  t
    .expect(FileRouterCodegen.validateRouteModule("string"))
    .toBe(false)

  t
    .expect(FileRouterCodegen.validateRouteModule(42))
    .toBe(false)
})

t.it("mixed params and rest in same route", () => {
  const handles: RouteHandle[] = [
    parseRoute("users/[userId]/files/[...path]/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("path: \"/users/[userId]/files/[...path]\"")
})

const effect = effectFn()

const update_FilesWithRoutes = {
  "/routes/route.tsx": "",
  "/routes/about/route.tsx": "",
  "/routes/_manifest.ts": "",
}

t.it("update() > writes file", () =>
  Effect
    .gen(function*() {
      yield* FileRouterCodegen.update("/routes")

      const fs = yield* FileSystem.FileSystem
      const content = yield* fs.readFileString("/routes/_manifest.ts")

      t
        .expect(content)
        .toContain("export const routes =")
    })
    .pipe(
      Effect.provide(MemoryFileSystem.layerWith(update_FilesWithRoutes)),
      Effect.runPromise,
    ))

t.it("update() > writes only when it changes", () =>
  Effect
    .gen(function*() {
      yield* FileRouterCodegen.update("/routes")

      const fs = yield* FileSystem.FileSystem
      const content = yield* fs.readFileString("/routes/_manifest.ts")

      yield* FileRouterCodegen.update("/routes")

      const content2 = yield* fs.readFileString("/routes/_manifest.ts")

      t
        .expect(content2)
        .not
        .toBe("")

      t
        .expect(content2)
        .toBe(content)
    })
    .pipe(
      Effect.provide(MemoryFileSystem.layerWith(update_FilesWithRoutes)),
      Effect.runPromise,
    ))

t.it("update() > removes deleted routes from manifest", () =>
  Effect
    .gen(function*() {
      const fs = yield* FileSystem.FileSystem

      yield* FileRouterCodegen.update("/routes")

      const content = yield* fs.readFileString("/routes/_manifest.ts")

      t
        .expect(content)
        .toContain("path: \"/\"")

      t
        .expect(content)
        .toContain("path: \"/about\"")

      yield* fs.remove("/routes/about/route.tsx")

      yield* FileRouterCodegen.update("/routes")

      const content2 = yield* fs.readFileString("/routes/_manifest.ts")

      t
        .expect(content2)
        .toContain("path: \"/\"")

      t
        .expect(content2)
        .not
        .toContain("path: \"/about\"")
    })
    .pipe(
      Effect.provide(MemoryFileSystem.layerWith(update_FilesWithRoutes)),
      Effect.runPromise,
    ))

t.it("update() > removes routes when entire directory is deleted", () =>
  Effect
    .gen(function*() {
      const fs = yield* FileSystem.FileSystem

      yield* fs.makeDirectory("/routes/users", { recursive: true })

      yield* fs.writeFileString("/routes/users/route.tsx", "")

      yield* FileRouterCodegen.update("/routes")

      const content = yield* fs.readFileString("/routes/_manifest.ts")

      t
        .expect(content)
        .toContain("path: \"/\"")

      t
        .expect(content)
        .toContain("path: \"/about\"")

      t
        .expect(content)
        .toContain("path: \"/users\"")

      yield* fs.remove("/routes/users", { recursive: true })

      yield* FileRouterCodegen.update("/routes")

      const content2 = yield* fs.readFileString("/routes/_manifest.ts")

      t
        .expect(content2)
        .toContain("path: \"/\"")

      t
        .expect(content2)
        .toContain("path: \"/about\"")

      t
        .expect(content2)
        .not
        .toContain("path: \"/users\"")
    })
    .pipe(
      Effect.provide(MemoryFileSystem.layerWith(update_FilesWithRoutes)),
      Effect.runPromise,
    ))
