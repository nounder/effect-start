import * as FileSystem from "@effect/platform/FileSystem"
import * as t from "bun:test"
import { MemoryFileSystem } from "effect-memfs"
import * as Effect from "effect/Effect"
import { parseRoute } from "./FileRouter.ts"
import type { RouteHandle } from "./FileRouter.ts"
import * as FileRouterCodegen from "./FileRouterCodegen.ts"
import * as Route from "./Route.ts"
import { effectFn } from "./testing.ts"

t.it("generates code for routes only", () => {
  const handles: RouteHandle[] = [
    parseRoute("route.tsx"),
    parseRoute("about/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  const expected = `/**
 * Auto-generated by effect-start.
 */

import type { Router } from "effect-start"

export const routes = [
  {
    path: "/",
    load: () => import("./route.tsx"),
  },
  {
    path: "/about",
    load: () => import("./about/route.tsx"),
  },
] as const
`

  t
    .expect(code)
    .toBe(expected)
})

t.it("generates code with layers", () => {
  const handles: RouteHandle[] = [
    parseRoute("layer.tsx"),
    parseRoute("route.tsx"),
    parseRoute("about/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  const expected = `/**
 * Auto-generated by effect-start.
 */

import type { Router } from "effect-start"

export const routes = [
  {
    path: "/",
    load: () => import("./route.tsx"),
    layers: [
      () => import("./layer.tsx"),
    ],
  },
  {
    path: "/about",
    load: () => import("./about/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
    ],
  },
] as const
`

  t
    .expect(code)
    .toBe(expected)
})

t.it("generates code with nested layers", () => {
  const handles: RouteHandle[] = [
    parseRoute("layer.tsx"),
    parseRoute("dashboard/layer.tsx"),
    parseRoute("dashboard/route.tsx"),
    parseRoute("dashboard/settings/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  const expected = `/**
 * Auto-generated by effect-start.
 */

import type { Router } from "effect-start"

export const routes = [
  {
    path: "/dashboard",
    load: () => import("./dashboard/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
      () => import("./dashboard/layer.tsx"),
    ],
  },
  {
    path: "/dashboard/settings",
    load: () => import("./dashboard/settings/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
      () => import("./dashboard/layer.tsx"),
    ],
  },
] as const
`

  t
    .expect(code)
    .toBe(expected)
})

t.it("only includes group layers for routes in that group", () => {
  const handles: RouteHandle[] = [
    parseRoute("layer.tsx"),
    parseRoute("(admin)/layer.ts"),
    parseRoute("(admin)/users/route.tsx"),
    parseRoute("movies/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("path: \"/users\"")

  t
    .expect(code)
    .toContain("path: \"/movies\"")

  // /users should have both root layer and (admin) layer
  t
    .expect(code)
    .toContain("() => import(\"./layer.tsx\")")

  t
    .expect(code)
    .toContain("() => import(\"./(admin)/layer.ts\")")

  // /movies should only have root layer, not (admin) layer
  const expectedMovies = `  {
    path: "/movies",
    load: () => import("./movies/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
    ],
  },`

  t
    .expect(code)
    .toContain(expectedMovies)
})

t.it("handles dynamic routes with params", () => {
  const handles: RouteHandle[] = [
    parseRoute("users/route.tsx"),
    parseRoute("users/[userId]/route.tsx"),
    parseRoute("posts/[postId]/comments/[commentId]/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("path: \"/users\"")
  t
    .expect(code)
    .toContain("path: \"/users/[userId]\"")
  t
    .expect(code)
    .toContain("path: \"/posts/[postId]/comments/[commentId]\"")
})

t.it("handles rest parameters", () => {
  const handles: RouteHandle[] = [
    parseRoute("docs/[[...slug]]/route.tsx"),
    parseRoute("api/[...path]/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("path: \"/docs/[[...slug]]\"")
  t
    .expect(code)
    .toContain("path: \"/api/[...path]\"")
})

t.it("handles groups in path", () => {
  const handles: RouteHandle[] = [
    parseRoute("(admin)/users/route.tsx"),
    parseRoute("(admin)/layer.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("path: \"/users\"") // groups stripped from URL
  t
    .expect(code)
    .toContain("layers: [\n      () => import(\"./(admin)/layer.tsx\"),\n    ]")
})

t.it("generates correct variable names for root routes", () => {
  const handles: RouteHandle[] = [
    parseRoute("route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("path: \"/\"")
})

t.it("handles routes with dots in path segments", () => {
  const handles: RouteHandle[] = [
    parseRoute("events.json/route.ts"),
    parseRoute("config.yaml.backup/route.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("path: \"/events.json\"")
  t
    .expect(code)
    .toContain("path: \"/config.yaml.backup\"")
})

t.it("uses default module identifier", () => {
  const handles: RouteHandle[] = [
    parseRoute("route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("import type { Router } from \"effect-start\"")
})

t.it("generates empty routes array when no handles provided", () => {
  const handles: RouteHandle[] = []

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("export const routes = [] as const")
})

t.it("only includes routes, not layers", () => {
  const handles: RouteHandle[] = [
    parseRoute("layer.tsx"),
    parseRoute("users/layer.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("export const routes = [] as const")
})

t.it("complex nested routes with multiple layers", () => {
  const handles: RouteHandle[] = [
    parseRoute("layer.tsx"),
    parseRoute("(auth)/layer.tsx"),
    parseRoute("(auth)/login/route.tsx"),
    parseRoute("(auth)/signup/route.tsx"),
    parseRoute("dashboard/layer.tsx"),
    parseRoute("dashboard/route.tsx"),
    parseRoute("dashboard/settings/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("path: \"/login\"") // group stripped
  t
    .expect(code)
    .toContain("path: \"/signup\"") // group stripped
  t
    .expect(code)
    .toContain("path: \"/dashboard\"")
  t
    .expect(code)
    .toContain("path: \"/dashboard/settings\"")

  // Check layers are properly inherited
  t
    .expect(code)
    .toContain("() => import(\"./layer.tsx\")")
  t
    .expect(code)
    .toContain("() => import(\"./(auth)/layer.tsx\")")
  t
    .expect(code)
    .toContain("() => import(\"./dashboard/layer.tsx\")")
})

t.it("handles routes with hyphens and underscores in path segments", () => {
  const handles: RouteHandle[] = [
    parseRoute("api-v1/route.ts"),
    parseRoute("my_resource/route.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("path: \"/api-v1\"")
  t
    .expect(code)
    .toContain("path: \"/my_resource\"")
})

t.it("validateRouteModule returns true for valid modules", () => {
  const validRoute = Route.text("Hello")

  t
    .expect(
      FileRouterCodegen.validateRouteModule({ default: validRoute }),
    )
    .toBe(true)

  t
    .expect(
      FileRouterCodegen.validateRouteModule({
        default: Route.html(Effect.succeed("<div>Hello</div>")),
      }),
    )
    .toBe(true)

  t
    .expect(
      FileRouterCodegen.validateRouteModule({
        default: Route.json({ message: "Hello" }),
      }),
    )
    .toBe(true)
})

t.it("validateRouteModule returns false for invalid modules", () => {
  t
    .expect(FileRouterCodegen.validateRouteModule({}))
    .toBe(false)

  t
    .expect(
      FileRouterCodegen.validateRouteModule({ default: {} }),
    )
    .toBe(false)

  t
    .expect(
      FileRouterCodegen.validateRouteModule({ default: "not a route" }),
    )
    .toBe(false)

  t
    .expect(
      FileRouterCodegen.validateRouteModule({ foo: "bar" }),
    )
    .toBe(false)

  t
    .expect(FileRouterCodegen.validateRouteModule(null))
    .toBe(false)

  t
    .expect(FileRouterCodegen.validateRouteModule(undefined))
    .toBe(false)

  t
    .expect(FileRouterCodegen.validateRouteModule("string"))
    .toBe(false)

  t
    .expect(FileRouterCodegen.validateRouteModule(42))
    .toBe(false)
})

t.it("mixed params and rest in same route", () => {
  const handles: RouteHandle[] = [
    parseRoute("users/[userId]/files/[...path]/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  t
    .expect(code)
    .toContain("path: \"/users/[userId]/files/[...path]\"")
})

t.describe("layerMatchesRoute", () => {
  t.it("layer in dynamic param dir only applies to routes in that dir", () => {
    const handles: RouteHandle[] = [
      parseRoute("[userId]/layer.tsx"),
      parseRoute("[userId]/posts/route.tsx"),
      parseRoute("[otherId]/route.tsx"),
    ]

    const code = FileRouterCodegen.generateCode(handles)

    const expectedUserIdPosts = `  {
    path: "/[userId]/posts",
    load: () => import("./[userId]/posts/route.tsx"),
    layers: [
      () => import("./[userId]/layer.tsx"),
    ],
  },`

    t
      .expect(code)
      .toContain(expectedUserIdPosts)

    const expectedOtherId = `  {
    path: "/[otherId]",
    load: () => import("./[otherId]/route.tsx"),
  },`

    t
      .expect(code)
      .toContain(expectedOtherId)
  })

  t.it("nested groups only apply to routes in those groups", () => {
    const handles: RouteHandle[] = [
      parseRoute("layer.tsx"),
      parseRoute("(admin)/(dashboard)/layer.tsx"),
      parseRoute("(admin)/(dashboard)/users/route.tsx"),
      parseRoute("(admin)/settings/route.tsx"),
      parseRoute("(other)/(dashboard)/route.tsx"),
    ]

    const code = FileRouterCodegen.generateCode(handles)

    const expectedAdminDashboardUsers = `  {
    path: "/users",
    load: () => import("./(admin)/(dashboard)/users/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
      () => import("./(admin)/(dashboard)/layer.tsx"),
    ],
  },`

    t
      .expect(code)
      .toContain(expectedAdminDashboardUsers)

    const expectedAdminSettings = `  {
    path: "/settings",
    load: () => import("./(admin)/settings/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
    ],
  },`

    t
      .expect(code)
      .toContain(expectedAdminSettings)

    const expectedOtherDashboard = `  {
    path: "/",
    load: () => import("./(other)/(dashboard)/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
    ],
  },`

    t
      .expect(code)
      .toContain(expectedOtherDashboard)
  })

  t.it("similar directory names do not match (user vs users)", () => {
    const handles: RouteHandle[] = [
      parseRoute("user/layer.tsx"),
      parseRoute("user/route.tsx"),
      parseRoute("users/route.tsx"),
    ]

    const code = FileRouterCodegen.generateCode(handles)

    const expectedUser = `  {
    path: "/user",
    load: () => import("./user/route.tsx"),
    layers: [
      () => import("./user/layer.tsx"),
    ],
  },`

    t
      .expect(code)
      .toContain(expectedUser)

    const expectedUsers = `  {
    path: "/users",
    load: () => import("./users/route.tsx"),
  },`

    t
      .expect(code)
      .toContain(expectedUsers)
  })

  t.it("mixed groups and literals layer matching", () => {
    const handles: RouteHandle[] = [
      parseRoute("(admin)/users/layer.tsx"),
      parseRoute("(admin)/users/[userId]/route.tsx"),
      parseRoute("users/route.tsx"),
      parseRoute("(admin)/posts/route.tsx"),
    ]

    const code = FileRouterCodegen.generateCode(handles)

    const expectedAdminUsersId = `  {
    path: "/users/[userId]",
    load: () => import("./(admin)/users/[userId]/route.tsx"),
    layers: [
      () => import("./(admin)/users/layer.tsx"),
    ],
  },`

    t
      .expect(code)
      .toContain(expectedAdminUsersId)

    const expectedUsers = `  {
    path: "/users",
    load: () => import("./users/route.tsx"),
  },`

    t
      .expect(code)
      .toContain(expectedUsers)

    const expectedAdminPosts = `  {
    path: "/posts",
    load: () => import("./(admin)/posts/route.tsx"),
  },`

    t
      .expect(code)
      .toContain(expectedAdminPosts)
  })

  t.it("param directory layer only applies to routes in that dir", () => {
    const handles: RouteHandle[] = [
      parseRoute("[tenantId]/layer.tsx"),
      parseRoute("[tenantId]/settings/route.tsx"),
      parseRoute("other/route.tsx"),
    ]

    const code = FileRouterCodegen.generateCode(handles)

    const expectedTenantSettings = `  {
    path: "/[tenantId]/settings",
    load: () => import("./[tenantId]/settings/route.tsx"),
    layers: [
      () => import("./[tenantId]/layer.tsx"),
    ],
  },`

    t
      .expect(code)
      .toContain(expectedTenantSettings)

    const expectedOther = `  {
    path: "/other",
    load: () => import("./other/route.tsx"),
  },`

    t
      .expect(code)
      .toContain(expectedOther)
  })

  t.it(
    "optional param directory layer only applies to routes in that dir",
    () => {
      const handles: RouteHandle[] = [
        parseRoute("[[id]]/layer.tsx"),
        parseRoute("[[id]]/settings/route.tsx"),
        parseRoute("other/route.tsx"),
      ]

      const code = FileRouterCodegen.generateCode(handles)

      const expectedIdSettings = `  {
    path: "/[[id]]/settings",
    load: () => import("./[[id]]/settings/route.tsx"),
    layers: [
      () => import("./[[id]]/layer.tsx"),
    ],
  },`

      t
        .expect(code)
        .toContain(expectedIdSettings)

      const expectedOther = `  {
    path: "/other",
    load: () => import("./other/route.tsx"),
  },`

      t
        .expect(code)
        .toContain(expectedOther)
    },
  )

  t.it("layer and route at same directory level", () => {
    const handles: RouteHandle[] = [
      parseRoute("users/layer.tsx"),
      parseRoute("users/route.tsx"),
    ]

    const code = FileRouterCodegen.generateCode(handles)

    const expected = `  {
    path: "/users",
    load: () => import("./users/route.tsx"),
    layers: [
      () => import("./users/layer.tsx"),
    ],
  },`

    t
      .expect(code)
      .toContain(expected)
  })
})

const effect = effectFn()

const update_FilesWithRoutes = {
  "/routes/route.tsx": "",
  "/routes/about/route.tsx": "",
  "/routes/_manifest.ts": "",
}

t.it("update() > writes file", () =>
  Effect
    .gen(function*() {
      yield* FileRouterCodegen.update("/routes")

      const fs = yield* FileSystem.FileSystem
      const content = yield* fs.readFileString("/routes/_manifest.ts")

      t
        .expect(content)
        .toContain("export const routes =")
    })
    .pipe(
      Effect.provide(MemoryFileSystem.layerWith(update_FilesWithRoutes)),
      Effect.runPromise,
    ))

t.it("update() > writes only when it changes", () =>
  Effect
    .gen(function*() {
      yield* FileRouterCodegen.update("/routes")

      const fs = yield* FileSystem.FileSystem
      const content = yield* fs.readFileString("/routes/_manifest.ts")

      yield* FileRouterCodegen.update("/routes")

      const content2 = yield* fs.readFileString("/routes/_manifest.ts")

      t
        .expect(content2)
        .not
        .toBe("")

      t
        .expect(content2)
        .toBe(content)
    })
    .pipe(
      Effect.provide(MemoryFileSystem.layerWith(update_FilesWithRoutes)),
      Effect.runPromise,
    ))

t.it("update() > removes deleted routes from manifest", () =>
  Effect
    .gen(function*() {
      const fs = yield* FileSystem.FileSystem

      yield* FileRouterCodegen.update("/routes")

      const content = yield* fs.readFileString("/routes/_manifest.ts")

      t
        .expect(content)
        .toContain("path: \"/\"")

      t
        .expect(content)
        .toContain("path: \"/about\"")

      yield* fs.remove("/routes/about/route.tsx")

      yield* FileRouterCodegen.update("/routes")

      const content2 = yield* fs.readFileString("/routes/_manifest.ts")

      t
        .expect(content2)
        .toContain("path: \"/\"")

      t
        .expect(content2)
        .not
        .toContain("path: \"/about\"")
    })
    .pipe(
      Effect.provide(MemoryFileSystem.layerWith(update_FilesWithRoutes)),
      Effect.runPromise,
    ))

t.it("update() > removes routes when entire directory is deleted", () =>
  Effect
    .gen(function*() {
      const fs = yield* FileSystem.FileSystem

      yield* fs.makeDirectory("/routes/users", { recursive: true })

      yield* fs.writeFileString("/routes/users/route.tsx", "")

      yield* FileRouterCodegen.update("/routes")

      const content = yield* fs.readFileString("/routes/_manifest.ts")

      t
        .expect(content)
        .toContain("path: \"/\"")

      t
        .expect(content)
        .toContain("path: \"/about\"")

      t
        .expect(content)
        .toContain("path: \"/users\"")

      yield* fs.remove("/routes/users", { recursive: true })

      yield* FileRouterCodegen.update("/routes")

      const content2 = yield* fs.readFileString("/routes/_manifest.ts")

      t
        .expect(content2)
        .toContain("path: \"/\"")

      t
        .expect(content2)
        .toContain("path: \"/about\"")

      t
        .expect(content2)
        .not
        .toContain("path: \"/users\"")
    })
    .pipe(
      Effect.provide(MemoryFileSystem.layerWith(update_FilesWithRoutes)),
      Effect.runPromise,
    ))
