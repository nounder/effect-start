import * as Error from "@effect/platform/Error"
import * as FileSystem from "@effect/platform/FileSystem"
import * as test from "bun:test"
import * as Effect from "effect/Effect"
import * as Schema from "effect/Schema"
import * as Scope from "effect/Scope"
import * as path from "node:path"
import * as NodeFileSystem from "../node/FileSystem.ts"
import * as SchemaExtra from "../SchemaExtra.ts"
import * as TestLogger from "../testing/TestLogger.ts"
import * as FileRouter from "./FileRouter.ts"
import { parseRoute } from "./FileRouter.ts"
import type { RouteHandle } from "./FileRouter.ts"
import * as FileRouterCodegen from "./FileRouterCodegen.ts"
import * as Route from "./Route.ts"

function createTempDirWithFiles(
  files: Record<string, string>,
): Effect.Effect<
  string,
  Error.PlatformError,
  FileSystem.FileSystem | Scope.Scope
> {
  return Effect.gen(function*() {
    const fs = yield* FileSystem.FileSystem
    const tempDir = yield* fs.makeTempDirectoryScoped()

    for (const [filePath, content] of Object.entries(files)) {
      const fullPath = path.join(tempDir, filePath)
      const dir = path.dirname(fullPath)

      yield* fs.makeDirectory(dir, { recursive: true })
      yield* fs.writeFileString(fullPath, content)
    }

    return tempDir
  })
}

test.it("generates code for routes only", () => {
  const handles: RouteHandle[] = [
    parseRoute("route.tsx"),
    parseRoute("about/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  const expected = `/**
 * Auto-generated by effect-start.
 */

export const routes = [
  {
    path: "/",
    load: () => import("./route.tsx"),
  },
  {
    path: "/about",
    load: () => import("./about/route.tsx"),
  },
] as const
`

  test
    .expect(code)
    .toBe(expected)
})

test.it("generates code with layers", () => {
  const handles: RouteHandle[] = [
    parseRoute("layer.tsx"),
    parseRoute("route.tsx"),
    parseRoute("about/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  const expected = `/**
 * Auto-generated by effect-start.
 */

export const routes = [
  {
    path: "/",
    load: () => import("./route.tsx"),
    layers: [
      () => import("./layer.tsx"),
    ],
  },
  {
    path: "/about",
    load: () => import("./about/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
    ],
  },
] as const
`

  test
    .expect(code)
    .toBe(expected)
})

test.it("generates code with nested layers", () => {
  const handles: RouteHandle[] = [
    parseRoute("layer.tsx"),
    parseRoute("dashboard/layer.tsx"),
    parseRoute("dashboard/route.tsx"),
    parseRoute("dashboard/settings/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  const expected = `/**
 * Auto-generated by effect-start.
 */

export const routes = [
  {
    path: "/dashboard",
    load: () => import("./dashboard/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
      () => import("./dashboard/layer.tsx"),
    ],
  },
  {
    path: "/dashboard/settings",
    load: () => import("./dashboard/settings/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
      () => import("./dashboard/layer.tsx"),
    ],
  },
] as const
`

  test
    .expect(code)
    .toBe(expected)
})

test.it("only includes group layers for routes in that group", () => {
  const handles: RouteHandle[] = [
    parseRoute("layer.tsx"),
    parseRoute("(admin)/layer.ts"),
    parseRoute("(admin)/users/route.tsx"),
    parseRoute("movies/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  test
    .expect(code)
    .toContain("path: \"/users\"")
  test
    .expect(code)
    .toContain("path: \"/movies\"")
  test
    .expect(code)
    .toContain("() => import(\"./layer.tsx\")")
  test
    .expect(code)
    .toContain("() => import(\"./(admin)/layer.ts\")")

  const expectedMovies = `  {
    path: "/movies",
    load: () => import("./movies/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
    ],
  },`

  test
    .expect(code)
    .toContain(expectedMovies)
})

test.it("handles dynamic routes with params", () => {
  const handles: RouteHandle[] = [
    parseRoute("users/route.tsx"),
    parseRoute("users/[userId]/route.tsx"),
    parseRoute("posts/[postId]/comments/[commentId]/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  test
    .expect(code)
    .toContain("path: \"/users\"")
  test
    .expect(code)
    .toContain("path: \"/users/[userId]\"")
  test
    .expect(code)
    .toContain("path: \"/posts/[postId]/comments/[commentId]\"")
})

test.it("handles rest parameters", () => {
  const handles: RouteHandle[] = [
    parseRoute("docs/[[...slug]]/route.tsx"),
    parseRoute("api/[...path]/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  test
    .expect(code)
    .toContain("path: \"/docs/[[...slug]]\"")
  test
    .expect(code)
    .toContain("path: \"/api/[...path]\"")
})

test.it("handles groups in path", () => {
  const handles: RouteHandle[] = [
    parseRoute("(admin)/users/route.tsx"),
    parseRoute("(admin)/layer.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  test
    .expect(code)
    .toContain("path: \"/users\"")
  test
    .expect(code)
    .toContain(
      "layers: [\n      () => import(\"./(admin)/layer.tsx\"),\n    ]",
    )
})

test.it("generates correct variable names for root routes", () => {
  const handles: RouteHandle[] = [
    parseRoute("route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  test
    .expect(code)
    .toContain("path: \"/\"")
})

test.it("handles routes with dots in path segments", () => {
  const handles: RouteHandle[] = [
    parseRoute("events.json/route.ts"),
    parseRoute("config.yaml.backup/route.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  test
    .expect(code)
    .toContain("path: \"/events.json\"")
  test
    .expect(code)
    .toContain("path: \"/config.yaml.backup\"")
})

test.it("uses default module identifier", () => {
  const handles: RouteHandle[] = [
    parseRoute("route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)
})

test.it("generates empty routes array when no handles provided", () => {
  const handles: RouteHandle[] = []

  const code = FileRouterCodegen.generateCode(handles)

  test
    .expect(code)
    .toContain("export const routes = [] as const")
})

test.it("only includes routes, not layers", () => {
  const handles: RouteHandle[] = [
    parseRoute("layer.tsx"),
    parseRoute("users/layer.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  test
    .expect(code)
    .toContain("export const routes = [] as const")
})

test.it("complex nested routes with multiple layers", () => {
  const handles: RouteHandle[] = [
    parseRoute("layer.tsx"),
    parseRoute("(auth)/layer.tsx"),
    parseRoute("(auth)/login/route.tsx"),
    parseRoute("(auth)/signup/route.tsx"),
    parseRoute("dashboard/layer.tsx"),
    parseRoute("dashboard/route.tsx"),
    parseRoute("dashboard/settings/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  test
    .expect(code)
    .toContain("path: \"/login\"")
  test
    .expect(code)
    .toContain("path: \"/signup\"")
  test
    .expect(code)
    .toContain("path: \"/dashboard\"")
  test
    .expect(code)
    .toContain("path: \"/dashboard/settings\"")
  test
    .expect(code)
    .toContain("() => import(\"./layer.tsx\")")
  test
    .expect(code)
    .toContain("() => import(\"./(auth)/layer.tsx\")")
  test
    .expect(code)
    .toContain("() => import(\"./dashboard/layer.tsx\")")
})

test.it("handles routes with hyphens and underscores in path segments", () => {
  const handles: RouteHandle[] = [
    parseRoute("api-v1/route.ts"),
    parseRoute("my_resource/route.ts"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  test
    .expect(code)
    .toContain("path: \"/api-v1\"")
  test
    .expect(code)
    .toContain("path: \"/my_resource\"")
})

test.it("validateRouteModule returns true for valid modules", () => {
  const validRoute = Route.text("Hello")

  test
    .expect(FileRouterCodegen.validateRouteModule({ default: validRoute }))
    .toBe(true)
  test
    .expect(FileRouterCodegen.validateRouteModule({
      default: Route.html(Effect.succeed("<div>Hello</div>")),
    }))
    .toBe(true)
  test
    .expect(FileRouterCodegen.validateRouteModule({
      default: Route.json({ message: "Hello" }),
    }))
    .toBe(true)
})

test.it("validateRouteModule returns false for invalid modules", () => {
  test
    .expect(FileRouterCodegen.validateRouteModule({}))
    .toBe(false)
  test
    .expect(FileRouterCodegen.validateRouteModule({ default: {} }))
    .toBe(false)
  test
    .expect(FileRouterCodegen.validateRouteModule({ default: "not a route" }))
    .toBe(false)
  test
    .expect(FileRouterCodegen.validateRouteModule({ foo: "bar" }))
    .toBe(false)
  test
    .expect(FileRouterCodegen.validateRouteModule(null))
    .toBe(false)
  test
    .expect(FileRouterCodegen.validateRouteModule(undefined))
    .toBe(false)
  test
    .expect(FileRouterCodegen.validateRouteModule("string"))
    .toBe(false)
  test
    .expect(FileRouterCodegen.validateRouteModule(42))
    .toBe(false)
})

test.it("mixed params and rest in same route", () => {
  const handles: RouteHandle[] = [
    parseRoute("users/[userId]/files/[...path]/route.tsx"),
  ]

  const code = FileRouterCodegen.generateCode(handles)

  test
    .expect(code)
    .toContain("path: \"/users/[userId]/files/[...path]\"")
})

test.describe("layerMatchesRoute", () => {
  test.it("layer in dynamic param dir only applies to routes in that dir", () => {
    const handles: RouteHandle[] = [
      parseRoute("[userId]/layer.tsx"),
      parseRoute("[userId]/posts/route.tsx"),
      parseRoute("[otherId]/route.tsx"),
    ]

    const code = FileRouterCodegen.generateCode(handles)

    const expectedUserIdPosts = `  {
    path: "/[userId]/posts",
    load: () => import("./[userId]/posts/route.tsx"),
    layers: [
      () => import("./[userId]/layer.tsx"),
    ],
  },`

    test
      .expect(code)
      .toContain(expectedUserIdPosts)

    const expectedOtherId = `  {
    path: "/[otherId]",
    load: () => import("./[otherId]/route.tsx"),
  },`

    test
      .expect(code)
      .toContain(expectedOtherId)
  })

  test.it("nested groups only apply to routes in those groups", () => {
    const handles: RouteHandle[] = [
      parseRoute("layer.tsx"),
      parseRoute("(admin)/(dashboard)/layer.tsx"),
      parseRoute("(admin)/(dashboard)/users/route.tsx"),
      parseRoute("(admin)/settings/route.tsx"),
      parseRoute("(other)/(dashboard)/route.tsx"),
    ]

    const code = FileRouterCodegen.generateCode(handles)

    const expectedAdminDashboardUsers = `  {
    path: "/users",
    load: () => import("./(admin)/(dashboard)/users/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
      () => import("./(admin)/(dashboard)/layer.tsx"),
    ],
  },`

    test
      .expect(code)
      .toContain(expectedAdminDashboardUsers)

    const expectedAdminSettings = `  {
    path: "/settings",
    load: () => import("./(admin)/settings/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
    ],
  },`

    test
      .expect(code)
      .toContain(expectedAdminSettings)

    const expectedOtherDashboard = `  {
    path: "/",
    load: () => import("./(other)/(dashboard)/route.tsx"),
    layers: [
      () => import("./layer.tsx"),
    ],
  },`

    test
      .expect(code)
      .toContain(expectedOtherDashboard)
  })

  test.it("similar directory names do not match (user vs users)", () => {
    const handles: RouteHandle[] = [
      parseRoute("user/layer.tsx"),
      parseRoute("user/route.tsx"),
      parseRoute("users/route.tsx"),
    ]

    const code = FileRouterCodegen.generateCode(handles)

    const expectedUser = `  {
    path: "/user",
    load: () => import("./user/route.tsx"),
    layers: [
      () => import("./user/layer.tsx"),
    ],
  },`

    test
      .expect(code)
      .toContain(expectedUser)

    const expectedUsers = `  {
    path: "/users",
    load: () => import("./users/route.tsx"),
  },`

    test
      .expect(code)
      .toContain(expectedUsers)
  })

  test.it("mixed groups and literals layer matching", () => {
    const handles: RouteHandle[] = [
      parseRoute("(admin)/users/layer.tsx"),
      parseRoute("(admin)/users/[userId]/route.tsx"),
      parseRoute("users/route.tsx"),
      parseRoute("(admin)/posts/route.tsx"),
    ]

    const code = FileRouterCodegen.generateCode(handles)

    const expectedAdminUsersId = `  {
    path: "/users/[userId]",
    load: () => import("./(admin)/users/[userId]/route.tsx"),
    layers: [
      () => import("./(admin)/users/layer.tsx"),
    ],
  },`

    test
      .expect(code)
      .toContain(expectedAdminUsersId)

    const expectedUsers = `  {
    path: "/users",
    load: () => import("./users/route.tsx"),
  },`

    test
      .expect(code)
      .toContain(expectedUsers)

    const expectedAdminPosts = `  {
    path: "/posts",
    load: () => import("./(admin)/posts/route.tsx"),
  },`

    test
      .expect(code)
      .toContain(expectedAdminPosts)
  })

  test.it("param directory layer only applies to routes in that dir", () => {
    const handles: RouteHandle[] = [
      parseRoute("[tenantId]/layer.tsx"),
      parseRoute("[tenantId]/settings/route.tsx"),
      parseRoute("other/route.tsx"),
    ]

    const code = FileRouterCodegen.generateCode(handles)

    const expectedTenantSettings = `  {
    path: "/[tenantId]/settings",
    load: () => import("./[tenantId]/settings/route.tsx"),
    layers: [
      () => import("./[tenantId]/layer.tsx"),
    ],
  },`

    test
      .expect(code)
      .toContain(expectedTenantSettings)

    const expectedOther = `  {
    path: "/other",
    load: () => import("./other/route.tsx"),
  },`

    test
      .expect(code)
      .toContain(expectedOther)
  })

  test.it(
    "optional param directory layer only applies to routes in that dir",
    () => {
      const handles: RouteHandle[] = [
        parseRoute("[[id]]/layer.tsx"),
        parseRoute("[[id]]/settings/route.tsx"),
        parseRoute("other/route.tsx"),
      ]

      const code = FileRouterCodegen.generateCode(handles)

      const expectedIdSettings = `  {
    path: "/[[id]]/settings",
    load: () => import("./[[id]]/settings/route.tsx"),
    layers: [
      () => import("./[[id]]/layer.tsx"),
    ],
  },`

      test
        .expect(code)
        .toContain(expectedIdSettings)

      const expectedOther = `  {
    path: "/other",
    load: () => import("./other/route.tsx"),
  },`

      test
        .expect(code)
        .toContain(expectedOther)
    },
  )

  test.it("layer and route at same directory level", () => {
    const handles: RouteHandle[] = [
      parseRoute("users/layer.tsx"),
      parseRoute("users/route.tsx"),
    ]

    const code = FileRouterCodegen.generateCode(handles)

    const expected = `  {
    path: "/users",
    load: () => import("./users/route.tsx"),
    layers: [
      () => import("./users/layer.tsx"),
    ],
  },`

    test
      .expect(code)
      .toContain(expected)
  })
})

const simpleRouteContent = `import * as Route from "${
  path.resolve(import.meta.dirname, "./Route.ts")
}"
export default Route.text("Hello")
`

test.it("update() > writes file", () =>
  Effect
    .gen(function*() {
      const fs = yield* FileSystem.FileSystem
      const tempDir = yield* createTempDirWithFiles({
        "routes/route.tsx": simpleRouteContent,
        "routes/about/route.tsx": simpleRouteContent,
      })
      const routesPath = path.join(tempDir, "routes")

      yield* FileRouterCodegen.update(routesPath)

      const content = yield* fs.readFileString(
        path.join(routesPath, "manifest.ts"),
      )

      test
        .expect(content)
        .toContain("export const routes =")
    })
    .pipe(
      Effect.scoped,
      Effect.provide(NodeFileSystem.layer),
      Effect.runPromise,
    ))

test.it("update() > writes only when it changes", () =>
  Effect
    .gen(function*() {
      const fs = yield* FileSystem.FileSystem
      const tempDir = yield* createTempDirWithFiles({
        "routes/route.tsx": simpleRouteContent,
        "routes/about/route.tsx": simpleRouteContent,
      })
      const routesPath = path.join(tempDir, "routes")

      yield* FileRouterCodegen.update(routesPath)

      const content = yield* fs.readFileString(
        path.join(routesPath, "manifest.ts"),
      )

      yield* FileRouterCodegen.update(routesPath)

      const content2 = yield* fs.readFileString(
        path.join(routesPath, "manifest.ts"),
      )

      test
        .expect(content2)
        .not
        .toBe("")
      test
        .expect(content2)
        .toBe(content)
    })
    .pipe(
      Effect.scoped,
      Effect.provide(NodeFileSystem.layer),
      Effect.runPromise,
    ))

test.it(
  "update() > removes deleted routes from manifest",
  () =>
    Effect
      .gen(function*() {
        const fs = yield* FileSystem.FileSystem
        const tempDir = yield* createTempDirWithFiles({
          "routes/route.tsx": simpleRouteContent,
          "routes/about/route.tsx": simpleRouteContent,
        })
        const routesPath = path.join(tempDir, "routes")

        yield* FileRouterCodegen.update(routesPath)

        const content = yield* fs.readFileString(
          path.join(routesPath, "manifest.ts"),
        )

        test
          .expect(content)
          .toContain("path: \"/\"")
        test
          .expect(content)
          .toContain("path: \"/about\"")

        yield* fs.remove(path.join(routesPath, "about/route.tsx"))

        yield* FileRouterCodegen.update(routesPath)

        const content2 = yield* fs.readFileString(
          path.join(routesPath, "manifest.ts"),
        )

        test
          .expect(content2)
          .toContain("path: \"/\"")
        test
          .expect(content2)
          .not
          .toContain("path: \"/about\"")
      })
      .pipe(
        Effect.scoped,
        Effect.provide(NodeFileSystem.layer),
        Effect.runPromise,
      ),
)

test.it(
  "update() > removes routes when entire directory is deleted",
  () =>
    Effect
      .gen(function*() {
        const fs = yield* FileSystem.FileSystem
        const tempDir = yield* createTempDirWithFiles({
          "routes/route.tsx": simpleRouteContent,
          "routes/about/route.tsx": simpleRouteContent,
          "routes/users/route.tsx": simpleRouteContent,
        })
        const routesPath = path.join(tempDir, "routes")

        yield* FileRouterCodegen.update(routesPath)

        const content = yield* fs.readFileString(
          path.join(routesPath, "manifest.ts"),
        )

        test
          .expect(content)
          .toContain("path: \"/\"")
        test
          .expect(content)
          .toContain("path: \"/about\"")
        test
          .expect(content)
          .toContain("path: \"/users\"")

        yield* fs.remove(path.join(routesPath, "users"), {
          recursive: true,
        })

        yield* FileRouterCodegen.update(routesPath)

        const content2 = yield* fs.readFileString(
          path.join(routesPath, "manifest.ts"),
        )

        test
          .expect(content2)
          .toContain("path: \"/\"")
        test
          .expect(content2)
          .toContain("path: \"/about\"")
        test
          .expect(content2)
          .not
          .toContain("path: \"/users\"")
      })
      .pipe(
        Effect.scoped,
        Effect.provide(NodeFileSystem.layer),
        Effect.runPromise,
      ),
)

test.describe("PathParams schema generation and validation", () => {
  test.describe("generatePathParamsSchema", () => {
    test.it("returns null for routes with no params", () => {
      const handle = parseRoute("users/route.tsx")
      const schema = FileRouterCodegen.generatePathParamsSchema(handle.segments)
      test
        .expect(schema)
        .toBe(null)
    })

    test.it("generates schema for single required param", () => {
      const handle = parseRoute("users/[id]/route.tsx")
      const schema = FileRouterCodegen.generatePathParamsSchema(handle.segments)
      test
        .expect(schema)
        .not
        .toBe(null)
      test
        .expect(Object.keys(schema!.fields))
        .toEqual(["id"])
    })

    test.it("generates schema for single optional param", () => {
      const handle = parseRoute("about/[[section]]/route.tsx")
      const schema = FileRouterCodegen.generatePathParamsSchema(handle.segments)
      test
        .expect(schema)
        .not
        .toBe(null)
      test
        .expect(Object.keys(schema!.fields))
        .toEqual(["section"])
    })

    test.it("generates schema for rest segment", () => {
      const handle = parseRoute("docs/[...path]/route.tsx")
      const schema = FileRouterCodegen.generatePathParamsSchema(handle.segments)
      test
        .expect(schema)
        .not
        .toBe(null)
      test
        .expect(Object.keys(schema!.fields))
        .toEqual(["path"])
    })

    test.it("rest segment should capture path starting with /", () => {
      const handle = parseRoute("docs/[...path]/route.tsx")
      const schema = FileRouterCodegen.generatePathParamsSchema(handle.segments)
      test
        .expect(schema)
        .not
        .toBe(null)

      const formatted = SchemaExtra.formatSchemaCode(schema!)
      test
        .expect(formatted)
        .toBe("{ path: Schema.String }")
    })

    test.it("generates schema for optional rest segment", () => {
      const handle = parseRoute("docs/[[...slug]]/route.tsx")
      const schema = FileRouterCodegen.generatePathParamsSchema(handle.segments)
      test
        .expect(schema)
        .not
        .toBe(null)
      test
        .expect(Object.keys(schema!.fields))
        .toEqual(["slug"])
    })

    test.it("generates schema for multiple params", () => {
      const handle = parseRoute("posts/[postId]/comments/[commentId]/route.tsx")
      const schema = FileRouterCodegen.generatePathParamsSchema(handle.segments)
      test
        .expect(schema)
        .not
        .toBe(null)
      test
        .expect(Object.keys(schema!.fields).sort())
        .toEqual([
          "commentId",
          "postId",
        ])
    })

    test.it("generates schema for mixed required and optional params", () => {
      const handle = parseRoute("users/[userId]/posts/[[postId]]/route.tsx")
      const schema = FileRouterCodegen.generatePathParamsSchema(handle.segments)
      test
        .expect(schema)
        .not
        .toBe(null)
      test
        .expect(Object.keys(schema!.fields).sort())
        .toEqual(["postId", "userId"])
    })

    test.it("ignores group segments", () => {
      const handle = parseRoute("(admin)/users/[id]/route.tsx")
      const schema = FileRouterCodegen.generatePathParamsSchema(handle.segments)
      test
        .expect(schema)
        .not
        .toBe(null)
      test
        .expect(Object.keys(schema!.fields))
        .toEqual(["id"])
    })
  })

  test.describe("schemaEqual", () => {
    test.it("returns true when both schemas are undefined/null", () => {
      test
        .expect(SchemaExtra.schemaEqual(undefined, null))
        .toBe(true)
    })

    test.it("returns false when only one schema is undefined", () => {
      const schema = Schema.Struct({ id: Schema.String })
      test
        .expect(SchemaExtra.schemaEqual(undefined, schema))
        .toBe(false)
      test
        .expect(SchemaExtra.schemaEqual(schema, null))
        .toBe(false)
    })

    test.it("returns true for exact matches", () => {
      const schema1 = Schema.Struct({ id: Schema.String })
      const schema2 = Schema.Struct({ id: Schema.String })
      test
        .expect(SchemaExtra.schemaEqual(schema1, schema2))
        .toBe(true)
    })

    test.it("returns true for refinement matches (UUID = String)", () => {
      const userSchema = Schema.Struct({ id: Schema.UUID })
      const expectedSchema = Schema.Struct({ id: Schema.String })
      test
        .expect(SchemaExtra.schemaEqual(userSchema, expectedSchema))
        .toBe(true)
    })

    test.it("returns false for type mismatches", () => {
      const schema1 = Schema.Struct({ id: Schema.String })
      const schema2 = Schema.Struct({ id: Schema.Number })
      test
        .expect(SchemaExtra.schemaEqual(schema1, schema2))
        .toBe(false)
    })

    test.it("returns false for field name mismatches", () => {
      const schema1 = Schema.Struct({ id: Schema.String })
      const schema2 = Schema.Struct({ userId: Schema.String })
      test
        .expect(SchemaExtra.schemaEqual(schema1, schema2))
        .toBe(false)
    })

    test.it("returns false for field count mismatches", () => {
      const schema1 = Schema.Struct({ id: Schema.String })
      const schema2 = Schema.Struct({ id: Schema.String, name: Schema.String })
      test
        .expect(SchemaExtra.schemaEqual(schema1, schema2))
        .toBe(false)
    })

    test.it("returns true for multiple fields with UUID refinement", () => {
      const userSchema = Schema.Struct({
        id: Schema.UUID,
        name: Schema.String,
      })
      const expectedSchema = Schema.Struct({
        id: Schema.String,
        name: Schema.String,
      })
      test
        .expect(SchemaExtra.schemaEqual(userSchema, expectedSchema))
        .toBe(true)
    })

    test.it("handles optional fields correctly", () => {
      const schema1 = Schema.Struct({
        id: Schema.String,
        name: Schema.optional(Schema.String),
      })
      const schema2 = Schema.Struct({
        id: Schema.String,
        name: Schema.optional(Schema.String),
      })
      test
        .expect(SchemaExtra.schemaEqual(schema1, schema2))
        .toBe(true)
    })
  })

  test.describe("formatSchemaCode", () => {
    test.it("formats single required field", () => {
      const schema = Schema.Struct({ id: Schema.String })
      const formatted = SchemaExtra.formatSchemaCode(schema)
      test
        .expect(formatted)
        .toBe("{ id: Schema.String }")
    })

    test.it("formats multiple fields", () => {
      const schema = Schema.Struct({
        id: Schema.String,
        count: Schema.Number,
      })
      const formatted = SchemaExtra.formatSchemaCode(schema)
      test
        .expect(formatted)
        .toContain("id: Schema.String")
      test
        .expect(formatted)
        .toContain("count: Schema.Number")
    })

    test.it("formats optional fields with ? marker", () => {
      const schema = Schema.Struct({
        id: Schema.String,
        name: Schema.optional(Schema.String),
      })
      const formatted = SchemaExtra.formatSchemaCode(schema)
      test
        .expect(formatted)
        .toContain("id: Schema.String")
      test
        .expect(formatted)
        .toContain("name")
    })

    test.it("formats boolean fields", () => {
      const schema = Schema.Struct({
        active: Schema.Boolean,
      })
      const formatted = SchemaExtra.formatSchemaCode(schema)
      test
        .expect(formatted)
        .toBe("{ active: Schema.Boolean }")
    })
  })

  test.describe("validateRouteModules", () => {
    test.it(
      "does not log when PathParams schema is missing",
      () =>
        Effect
          .gen(function*() {
            const fs = yield* FileSystem.FileSystem
            const routeContent = `import * as Route from "${
              path.resolve(import.meta.dirname, "./Route.ts")
            }"
export default Route.text("User")
`
            const tempDir = yield* createTempDirWithFiles({
              "routes/users/[id]/route.tsx": routeContent,
            })
            const routesPath = path.join(tempDir, "routes")

            const files = yield* fs.readDirectory(routesPath, {
              recursive: true,
            })
            const handles = FileRouter.getRouteHandlesFromPaths(files)

            yield* FileRouterCodegen.validateRouteModules(routesPath, handles)

            const messages = yield* TestLogger.messages
            test
              .expect(messages)
              .toHaveLength(0)
          })
          .pipe(
            Effect.scoped,
            Effect.provide([
              TestLogger.layer(),
              NodeFileSystem.layer,
            ]),
            Effect.runPromise,
          ),
    )

    test.it(
      "logs error when PathParams schema is incorrect",
      () =>
        Effect
          .gen(function*() {
            const fs = yield* FileSystem.FileSystem
            const schemaPath = path.resolve(
              import.meta.dirname,
              "../../node_modules/effect/Schema",
            )
            const routeContent = `import * as Route from "${
              path.resolve(import.meta.dirname, "./Route.ts")
            }"
import * as Schema from "${schemaPath}"
export default Route.text("User").schemaPathParams({ userId: Schema.String })
`
            const tempDir = yield* createTempDirWithFiles({
              "routes/users/[id]/route.tsx": routeContent,
            })
            const routesPath = path.join(tempDir, "routes")

            const files = yield* fs.readDirectory(routesPath, {
              recursive: true,
            })
            const handles = FileRouter.getRouteHandlesFromPaths(files)

            yield* FileRouterCodegen.validateRouteModules(routesPath, handles)

            const messages = yield* TestLogger.messages
            test
              .expect(messages)
              .toHaveLength(1)
            test
              .expect(messages[0])
              .toContain("[Error]")
            test
              .expect(messages[0])
              .toContain("incorrect PathParams schema")
            test
              .expect(messages[0])
              .toContain("expected schemaPathParams")
          })
          .pipe(
            Effect.scoped,
            Effect.provide([
              TestLogger.layer(),
              NodeFileSystem.layer,
            ]),
            Effect.runPromise,
          ),
    )
  })
})
